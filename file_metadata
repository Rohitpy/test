class
TeradataManager:
→ file_metadata_service.py 2 13
Singleton Teradata connection manager with thread pooling and async support.
_instance - None
_lock - threading-Lock()
def _new_(cls):
*"Ensure only one instance exists (Singleton pattern)."** if cls._ instance is None:
with cls._lock:
if cls. instance is None:
return cls. _instance
cis. instance - super (TeradataManager, cls)-new_(cls)
I
det
_init (self):
"*"Initialize only once due to singleton pattern."*" if hasattr(self, '_initialized') and self._initialized:
return
self.pool_size - getattr(settings, 'TERADATA POOL_SIZE', 10)
self connection timeout - getattr(settings, 'TERADATA CONNECTION_TIMEOUT"', 10) self-query_timeout - getattr (settings, 'TERADATA_QUERY_TIMEOUT', 300) self-pool recycle - getattr(settings, 'TERADATA POOL_ RECYCLE', 3680)
self._connection pool - Queue(maxsize=self.pool size)
self. _active_connections - ()
self._pool_lock = threading-RLock()
self. _executor - ThreadPoolExecutorg max workers=self.pool size * 2
thread_ name_prefix-"teradata worker"
49
50
51
52
self._total_connections - 0
self._failed_queries - e
self._total_queries = e
53
54
55
56
57
58
59
60
self._initialized - True
logger.info(f"Initialized Teradata connection manager with pool size (self.pool_size)")
def _create_connection(self):
•'"Create a new Teradata connection."** try:
61
62
63
64
65
66
connection - teradatasq].connectl] host-settings. TERADATA_HOST, user=settings. TERADATA_USER,
Siddharth TIWARI, 2 weeks ago] Add db maanager and test
password=settings. TERADATA_PASSWORD,
ca
database-settings. TERADATA_DATABASE, connect_timeout=self.connection_timeout
67
68
69
70
71
72
73
74
self._total_connections += 1
logger debug(f"Created new Teradata connection (total: (self._total_connections))")
return {
'connection': connection,
'created_at': time.time(),
'last_used': time.time(),
76
'last_used': time.time(),
'query_count': e
77
78
79
except Exception as
80
81
logger error(f"Failed to create Teradata connection: {str(e)}") raise
82
83
84
85
86
87
88
@contextmanager def get_connection(self):
conn_info = None
"'"Get a connection from the pool with automatic return."**
thread_id - threading-get_ident()
try:
89
90
91
92
93
94
95
with self._pool_lock:
if thread_id in self._active_connections:
conn_info - self._active_connections[thread_id] logger debug("Reusing existing thread connection")
yield conn_ info[ 'connection' ] return
96
97
try:
98
conn_info - self._connection_pool-get (block-False)
99
100
101
if time time() - conn_info['created_at '] › self.pool recycle:
self-_close_connection(conn_info[ 'connection'])

conn_into - self._create_connection()
except Empty:
conn_info = self._create_connection()
with self._pool _lock:
self. _active_connections[thread_id] - conn_ info
yield conn_infol 'connection']
except Exception as e:
logger.error (f"Error managing connection: {str(e)}™)
if conn info and 'connection' in conn info:
self-_close_connection(conn_info[' connection'])
raise
finally:
if conn_info:
with self._pool_lock:
self._active_connections.pop(thread_id, None)
conn_info['last_used'] - time. time()
conn_info[ query_count'] += 1
try:
self._connection_pool.put_nowait(conn_info)
except :
self._ close connection(conn_info['connection'])
129
def
130
131
close_connection(self, connection):
''"Close a connection safely.""" try:
132
133
134
135
136
if
connection and not connection. closed:
connection. close()
except Exception as e:
logger warning(f"Error closing connection: {str(e)}")
137
138
139
140
def execute_query(self, query: str, params: Optional [Any] = None):
"'"Execute a SQL query using a connection from the pool."** try:
141
142
with self-get_connection)
as conn:
cursor = conn.cursor()
143
try:
144
if params:
145
cursor. execute(query, params)
146
else:
147
I cursor. execute(query)
148
149
150
if query strip() upper () startswith ("SELECT"):
result - cursor.fetchall()
151
else:
152
153
conn. commit()
result = cursor. rowcount
154
155
156
self-_total_queries += 1
return result
157
158
159
except Exception as e:
logger.error(f"Query execution failed: {str(e)}")
raise
168
169
170
171
172
173
174
175
176
async def execute_query_async(self, query:
"'"Execute a SQL query asynchronously."""
str, params: Optional[Any] = None):
loop = asyncio-get_running_loop()
return await loop. run_in_ executor(
self._executor, self.execute_query, query. params
177
178
179
180
181
182
183
184
185
186
def test_connection(self) -> boal:
"'"Test if the connection is working."*" try:
self. execute_query ("SELECT 1")
return True
except Exception as e:
logger. error (f"Connection test failed: {str(e)]") return False
187
188
189
190
191
192
def
get_stats(self) -> Dict[str, Any]:
"*"Get basic connection statistics. """ with self._pool_lock:
active_count - len(self. _active_connections)
pool_count - self._connection_pool qsize()
def get_stats(self) -›> Dict[str, Any]:
_create_connection
return i
"total_connections": self. _total_connections,
"active_connections": active_count,
"pooled _connections": pool_count,
"total_queries": self._total_queries,
"failed_queries": self. _failed_queries
def shutdown(self):
"*"Shut down the connection manager."*"
logger.info("Shutting down Teradata connection manager")
self._executor.shutdown (wait-True)
with self._pool lock:
for conn_info in self._active_connections.values(): self-_close_connection (conn_info[ 'connection'])
self._active_connections.clear()
while not self._connection_pool. empty():
try:
conn_info - self._connection_pool get_nowait() self._close_connectioff(conn_info[' connection'])
except:
logger. info("Teradata connection manager shutdown complete")

