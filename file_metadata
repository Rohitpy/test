import logging
import json
from typing import Dict, Any
#from app.models.llm.llm_service import LLMService
from app.models.database.db_manager import TeradataManager

logging.basicConfig(level=logging.INFO,
                   format='%(asctime)s - %(levelname)s - %(message)s')

# Hardcoded schema definition
DOCUMENT_SCHEMA = {
    "table_name": "DOCUMENT_METADATA",
    "columns": [
        {"name": "DOC_ID", "type": "INTEGER", "description": "Unique identifier for the document"},
        {"name": "TITLE", "type": "VARCHAR(255)", "description": "Document title"},
        {"name": "FILE_TYPE", "type": "VARCHAR(50)", "description": "Type of document (PDF, DOCX, etc)"},
        {"name": "CREATED_DATE", "type": "TIMESTAMP", "description": "Document creation date"},
        {"name": "MODIFIED_DATE", "type": "TIMESTAMP", "description": "Last modification date"},
        {"name": "AUTHOR", "type": "VARCHAR(100)", "description": "Document author"},
        {"name": "DEPARTMENT", "type": "VARCHAR(100)", "description": "Department owning the document"},
        {"name": "TAGS", "type": "VARCHAR(500)", "description": "Comma-separated tags"},
        {"name": "STATUS", "type": "VARCHAR(50)", "description": "Document status (ACTIVE, ARCHIVED, etc)"}
    ]
}

class FileMetadataService:
    def __init__(self):
        #self.llm_service = LLMService()
        self.db_manager = TeradataManager()
        self.schema_prompt = self._format_schema_prompt()

    def _format_schema_prompt(self) -> str:
        """Format the schema into a prompt-friendly string"""
        prompt = f"Table Name: {DOCUMENT_SCHEMA['table_name']}\nColumns:\n"
        for col in DOCUMENT_SCHEMA['columns']:
            prompt += f"- {col['name']} ({col['type']}): {col['description']}\n"
        return prompt

    async def generate_sql_query(self, user_query: str) -> str:
        """Generate SQL query using LLM based on schema and user query"""
        prompt = f"""
        Based on the following table schema, generate a Teradata SQL query for this user request.
        
        {self.schema_prompt}
        
        User Query: {user_query}
        
        Return only the SQL query without any explanations.
        """
        return await "Select * from documents"#self.llm_service.generate_response(prompt)

    async def validate_and_execute_query(self, sql_query: str, user_query: str) -> Dict[str, Any]:
        """Execute query and handle errors with LLM assistance"""
        try:
            results = "Total 5 documents"#await self.db_manager.execute_query_async(sql_query)
            return {
                "status": "success",
                "data": results,
                "sql_query": sql_query
            }
        except Exception as e:
            error_prompt = f"""
            The SQL query failed with an error:
            
            Original Query: {sql_query}
            Schema: {self.schema_prompt}
            User Request: {user_query}
            Error: {str(e)}
            
            Please provide a corrected SQL query.
            """
            corrected_query ="Select * from documents" #await self.llm_service.generate_response(error_prompt)
            return await self.validate_and_execute_query(corrected_query, user_query)

    async def get_query(self, user_query: str) -> Dict[str, Any]:
        """Main method to process user queries"""
        try:
            sql_query = await self.generate_sql_query(user_query)
            result = await self.validate_and_execute_query(sql_query, user_query)
            return result
        except Exception as e:
            logging.error(f"Query processing failed: {str(e)}")
            raise


from pydantic import BaseModel
from typing import List, Any, Optional

class FileMetadataRequest(BaseModel):
    query: str
    filters: Optional[dict] = None

class FileMetadataResponse(BaseModel):
    status: str
    data: List[Any]
    query: str
    sql_query: Optional[str] = None


from fastapi import APIRouter, Depends, HTTPException
from app.services.file_metadata.file_metadata_service import FileMetadataService
from app.api.schemas.file_metadata import FileMetadataRequest, FileMetadataResponse
from app.services.authentication.ldap_auth import get_current_user

router = APIRouter()

@router.post("/search", response_model=FileMetadataResponse)
async def search_documents(
    request: FileMetadataRequest,
    current_user: str = Depends(get_current_user)
):
    try:
        service = FileMetadataService()
        result = await service.get_query(request.query)
        return FileMetadataResponse(
            status="success",
            data=result["data"],
            query=request.query,
            sql_query=result.get("sql_query")
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
